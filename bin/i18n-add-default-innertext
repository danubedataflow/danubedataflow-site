#!/usr/bin/env perl
use strict;
use warnings;
use feature qw(:5.36);
use FindBin qw($Bin);
use lib "$Bin/../perllib";
use Getopt::Long;
use DanubeDataflow;
use Path::Tiny;
use open qw(:std :utf8);
my %opt;
GetOptions(\%opt, qw(src|s=s www|w=s)) or die;
for (qw(src www)) { defined $opt{$_} or die "need --$_\n" }
my $combined = i18n_assemble_dicts($opt{src});
my $iter     = path($opt{www})->iterator({ recurse => 1 });

while (my $next = $iter->()) {
    next unless $next =~ /\.html$/;
    my $html = $next->slurp_utf8;
    $html =~ s!\bdata-i18n-key="(.*?)".*?>\K(?=<)! get_string_for_key($1) !ge;
    $next->spew_utf8($html);
}

sub get_string_for_key ($key) {
    if (defined(my $string = $combined->{en}{$key})) {
        return $string;
    } else {

        # If a key is used in multiple files, we only want one warning.
        our %did_warn_for_key;
        unless ($did_warn_for_key{$key}) {
            warn "missing key for language 'en': $key\n";
            $did_warn_for_key{$key}++;
        }
        return "missing key: $1";
    }
}

=pod

This program crudely adds English texts as the inner texts of tags that use the
C<data-i18n-key> attribute.

This way the English texts are already on the live site so Google can index
them.

=cut

#!/usr/bin/env perl
use GoGameTools::features;
use FindBin qw($Bin);
use lib "$Bin/../perllib";
use GoGameTools::Getopt;
use GoGameTools::JSON;
use DanubeDataflow;
use open qw(:std :utf8);
my %opt      = get_options(qw(+dir|d=s));
my $combined = i18n_assemble_dicts($opt{dir});
my $json     = json_encode($combined);
1 while chomp $json;
say <<~EOJS;
    // Do not edit this file; it was assembled from the raw dictionaries.

    const translations = $json;
    EOJS

=pod

Assuming there are JSON files named after locales like C<path/to/lang-en.json>,
C<path/to/lang-ja.json> etc., use

    ./bin/i18n-assemble-dicts **/lang*.json >src/js/i18n-dicts.js

Dictionaries with the same locale will be merged. This makes it possible to
define longer or one-off translations in the directory where they belong, and
they don't clutter up the main dictionaries in etc/. The per-dir JSON files
will be ignored in ttreerc.

We iterate over each key-value pair. If the value is a hash itself, its key is
interpreted to be a locale and its value the translation for that locale. That
way you can have multiple definitions for the same data-i18n-key in the same
file, which keeps things more compact. Example:

   { "some-key" : { "de" => "...", "en" => "...", "ja" => "..." }

If a locale is specified this way, it overrides a possible locale in the
filename.

=cut

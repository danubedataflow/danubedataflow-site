#!/usr/bin/env perl
use strict;
use warnings;
use feature qw(:5.36);
use FindBin qw($Bin);
use lib "$Bin/../perllib";
use Getopt::Long;
use DanubeDataflow;
use JSON::PP;
use open qw(:std :utf8);
my %opt;
GetOptions(\%opt, qw(dir|d=s)) or die;
defined $opt{dir}              or die "need --dir\n";
my $combined = i18n_assemble_dicts($opt{dir});
my $json =
  JSON::PP->new->allow_nonref->canonical(1)->pretty(1)->convert_blessed(1)
  ->encode($combined);
1 while chomp $json;
say <<~EOJS;
    // Do not edit this file; it was assembled from the raw dictionaries.

    const translations = $json;
    EOJS

=pod

Assuming there are JSON files named after locales like C<path/to/lang-en.json>,
C<path/to/lang-ja.json> etc., use

    ./bin/i18n-assemble-dicts **/lang*.json >src/js/i18n-dicts.js

Dictionaries with the same locale will be merged. This makes it possible to
define longer or one-off translations in the directory where they belong, and
they don't clutter up the main dictionaries in etc/. The per-dir JSON files
will be ignored in ttreerc.

We iterate over each key-value pair. If the value is a hash itself, its key is
interpreted to be a locale and its value the translation for that locale. That
way you can have multiple definitions for the same data-i18n-key in the same
file, which keeps things more compact. Example:

   { "some-key" : { "de" => "...", "en" => "...", "ja" => "..." }

If a locale is specified this way, it overrides a possible locale in the
filename.

=cut
